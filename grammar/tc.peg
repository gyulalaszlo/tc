{
  merge_expr = function(name, left, right) {
    var result = left;
    for (var i = 0; i < right.length; i++) {
      part = right[i];
      // if we may have the op also
      result = { _type: name,  a:result, b:part[part.length - 1 ] };
      if (part.length > 1) {
        result.op = part[0]
      }
      
    }
    return result;
  }
}


start
  = package:PackageDecl contents:Contents !. ->{{ COMPILATION_UNIT with package, contents }}

NL_CHARS = [\n\r]

COMMENT "Comment"
  = "//" (!NL_CHARS . )*


WS_PART
  = COMMENT
  / [\t\v\f\n\r \u00A0\uFEFF]+

WS "whitespace"
  = WS_PART*

SE "Statement Terminator ';'"
  = [;\n\r] WS?

////////////////////////////////////////////////////////////////////////////////

PackageDecl "Package declaration"
  = "package" WS name:Identifier SE ->{{ PACKAGE with  name }}


Contents "Compilation Unit contents"
  = declarations:RootStatementList ->{{ CONTENTS with declarations }}


RootStatementList "Statement List"
  = RootStatement*

RootStatement "Root declaration statements"
  = TypeStatement
  / MethodList

////////////////////////////////////////////////////////////////////////////////

TypeStatement "Type Statement"
  //= name:TypeStatementDeclaration "=" WS definition:TypeDefinition_ SE // { return ["TYPEDECL", name, definition]; }
  = name:TypeStatementDeclaration "=" WS definition:TypeDefinition_ SE ->{{ TYPEDECL with name, definition }}


TypeStatementDeclaration "Type Declaration"
  = "type" WS name: Identifier WS { return name; }


TypeDefinition_ "Type Definition"
  = s:StructDefinition_ { return s; }
  / a:AliasDefinition_ { return a; }
  / c:CTypeDefinition_ { return c; }
  / d:ClassDefinition_ { return d; }

////////////////////////////////////////////////////////////////////////////////

ClassDefinition_
  = "class" WS fields:StructFieldList_ ->{{ CLASS with fields }}


////////////////////////////////////////////////////////////////////////////////
StructDefinition_
  = "struct" WS fields:StructFieldList_ ->{{ STRUCT with fields }}


StructFieldList_
  = "{" WS fields:FieldDeclaration* "}" ->{{ FIELDS with fields }}


FieldDeclaration "Struct Field Declaration"
  = decl:VariableDeclaration_ SE { return decl; }

VariableDeclaration_ "Variable Declaration"
  = type:TypeName_ WS name:Identifier ->{{ VAR with type, name }}

////////////////////////////////////////////////////////////////////////////////

CTypeDefinition_ "A C type definition"
  = "C" WS c_name:TypeName_ ->{{ CTYPE with c_name  }}

////////////////////////////////////////////////////////////////////////////////

AliasDefinition_ "Alias"
  = "alias" WS original:TypeName_ ->{{ ALIAS with original }}

TypeName_ "Type Name"
  = name:Identifier  ->{{ TYPE with name }}

////////////////////////////////////////////////////////////////////////////////

Identifier "identifier"
  = text:IdentifierName  ->{{ IDENTIFIER with text }}

IdentifierName
  = start:[a-zA-Z_] cont:[a-zA-Z0-9_]* { return [start, cont.join("")].join(""); }

////////////////////////////////////////////////////////////////////////////////

MethodList "Method list"
  = access:MethodAccessor WS name:Identifier
    WS "=" WS body:MethodListBody SE
    ->{{ METHODS with name, access, body }}

MethodListBody "Method List body"
  = "{" WS  decls:MethodDeclaration* "}" { return decls; }

MethodDeclaration "Method Declaration"
  = name:Identifier WS "=" WS func:FunctionDeclaration
    ->{{ METHOD with name, func }}

MethodAccessor "Method acess controll"
  = "public"
  / "protected"
  / "private"


FunctionDeclaration "Function declaration"
  = "fn" WS args:FunctionArgList returns:FunctionReturnType body:FunctionBody
    ->{{ FUNC with args, body, returns }}

FunctionArgList "Type list for function parameters/return values"
  = "(" WS args:FunctionDeclarationArgumentList ")" WS { return args; }

FunctionReturnType
  = list: TypeList { return list; }

FunctionDeclarationArgumentList
  = first:FunctionArgumentFirst WS more:FunctionArgumentMore*
    //{ return [ "ARGS", [first].concat( more ) ];}
    { return { _type: "ARGS", list: [first].concat( more ) };}
  / { return { _type: "ARGS", list: []} }

FunctionArgumentFirst
  = decl:VariableDeclaration_ ->{{ ARG with decl }}


FunctionArgumentMore
  = ',' WS decl:VariableDeclaration_ WS ->{{ ARG with decl }}


FunctionBody
  = "{" WS c:FunctionBodyContents  "}" WS { return c; }

////////////////////////////////////////////////////////////////////////////////

TypeList "A list of types"
  = first:Typename_ WS more:MoreTypes* { return { _type:"TYPELIST", list: [first].concat(more) }; }
  / { return {_type:"TYPELIST", list:[] }; }

MoreTypes = "," WS more:Typename_ WS

Typename_ "Type name"
  = name:Identifier ->{{ TYPENAME with name }}

////////////////////////////////////////////////////////////////////////////////

FunctionBodyContents
  = statements:FunctionBodyElement* ->{{ BODY with statements }}


FunctionBodyElement
  = s:Statement_ SE { return s }

Statement_
  = Expression_
  //= s:ReturnStatement_ { return s; }
  /// Expression_

ReturnStatement_
  = "return" WS expr:Expression_ ->{{ RETURN with expr }}

Expression_
  = head:AssignmentExpression
    tail:(WS "," WS b:AssignmentExpression { return b; })*
    { return merge_expr( "EXPR", head, tail ); }

PrimaryExpression
  = ThisToken       {  return { _type: "THIS" }; }
  / name:Identifier ->{{ VARIABLE with name }}
  /// Literal
  /// ArrayLiteral
  /// ObjectLiteral
  / "(" WS expression:Expression_ WS ")" { return expression; }

ThisToken = "this"
////////////////////////////////////////////////////////////////////////////////

InitializeExpression_ "Declare and initialize the variable"
  = variable:Identifier WS ":=" WS expr:Expression_ ->{{ INIT with variable, expr }}

VariableAccessExpression_ "Accessing a variable"
  = variable:Identifier

////////////////////////////////////////////////////////////////////////////////

AssignmentExpression =
  a:LeftHandSideExpression WS
  op:AssignmentOperator WS
  b:AssignmentExpression ->{{ E_ASSIGN with a, op, b }}

  / e:EqualityExpression { return e; }

EqualityExpression =
  head:RelationalExpression
  tail:(WS op:EqualityOperator WS c:RelationalExpression { return [op, c]; })*
    { return merge_expr( "E_EQ", head, tail ); }

RelationalExpression =
  head:ShiftExpression
  tail:(WS op:RelationalOperator WS b:ShiftExpression { return [op, b]; })*
    { return merge_expr( "E_RELATIONAL", head, tail ); }


ShiftExpression =
  head:AdditiveExpression
  tail:(WS op:ShiftOperator WS b:AdditiveExpression { return [op, b]; })*
    { return merge_expr( "E_SHIFT", head, tail ); }

AdditiveExpression =
  head:MultiplicativeExpression
  tail:(WS op:AdditiveOperator WS c:MultiplicativeExpression {return [op, c];})*
    { return merge_expr( "E_ADD", head, tail ); }

MultiplicativeExpression =
  head:UnaryExpression
  tail:(WS op:MultiplicativeOperator WS b:UnaryExpression { return [op, b];})*
    { return merge_expr( "E_MUL", head, tail ); }

UnaryExpression
  = e:PostfixExpression { return e; }
  / op:UnaryOperator a:UnaryExpression ->{{ E_UNARY with op, a }}

PostfixExpression
  = a:LeftHandSideExpression op:PostfixOperator ->{{ E_POSTFIX with op, a }}
  / e:LeftHandSideExpression { return e; }

LeftHandSideExpression
  = c:CallExpression
  / NewExpression

//CallExpression =

NewExpression
  = MemberExpression
  / "new" WS type:Identifier ->{{ NEW with type }}

CallExpression
  = base:(
    name:MemberExpression WS args:Arguments
  )
  argumentsOrAccessors:(
      WS args:Arguments
    / WS "[" WS name:Expression_ WS "]"
    / WS "." WS name:IdentifierName 
  )*
MemberExpression
  = base:(
    PrimaryExpression
    /// FunctionExpression
    / "new" WS constructor:MemberExpression WS args:Arguments 
  )
  accessors:(
    WS "[" WS name:Expression_ WS "]" { return name; }
    / WS "." WS name:IdentifierName    { return name; }
  )*

    //BitwiseANDExpression = a:EqualityExpression WS
    //BitwiseANDOperator WS 
Arguments
  = "(" WS args:ArgumentList? WS ")" {
    return args !== null ? args : [];
  }

ArgumentList
  = head:AssignmentExpression tail:(WS "," WS AssignmentExpression)* 
////////////////////////////////////////////////////////////////////////////////

AssignmentOperator
  = "=" (!"=") { return "="; }
  / "*="
  / "/="
  / "%="
  / "+="
  / "-="
  / "<<="
  / ">>="
  / ">>>="
  / "&="
  / "^="
  / "|="
  / ":="


MultiplicativeOperator
  = operator:("*" / "/" / "%") !"=" { return operator; }

AdditiveOperator
  = "+" !("+" / "=") { return "+"; }
  / "-" !("-" / "=") { return "-"; }

UnaryOperator
  = "++"
  / "--"
  / "+"
  / "-"
  / "~"
  /  "!"

ShiftOperator
  = "<<"
  / ">>>"
  / ">>"

RelationalOperator
  = "<="
  / ">="
  / "<"
  / ">"

PostfixOperator
  = "++"
  / "--"

EqualityOperator
  = "==="
  / "!=="
  / "=="
  / "!="
////////////////////////////////////////////////////////////////////////////////
